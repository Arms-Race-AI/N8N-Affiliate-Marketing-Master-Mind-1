  async function ingestSmart(files, opts={}){
    if(!files || !files.length){ notify('warn','No files selected for ingest.'); return; }
    if(!window.JSZip || !window.Papa || !window.XLSX){ notify('danger','Parsing libraries missing. Reload recommended.'); return; }
    const ctx = {
      diag:[],
      errors:[],
      successes:[],
      pendingGeom:[],
      best:{
        council:{score:-Infinity,detail:'',rows:0,source:null},
        agency:{score:-Infinity,detail:'',rows:0,source:null},
        backlog:{score:-Infinity,detail:'',rows:0,source:null},
        fast:{score:-Infinity,detail:'',rows:0,source:null}
      },
      updated:new Set()
    };
    ctx.diag.push(`[INFO] ingest start (${files.length} file(s))`);
    const expanded = await flattenIngestFiles(files, ctx);
    ctx.diag.push(`? ${expanded.length} analyzable file(s)`);
    for(const info of expanded){
      ctx.diag.push(`? ${info.path}`);
      try{
        if(info.ext==='json' || info.ext==='geojson'){
          const txt = await info.file.text();
          const parsed = tryParse(txt);
          if(!parsed){ ctx.diag.push('[WARN] invalid JSON'); continue; }
          if(handleJsonStructure(ctx, info, parsed)) continue;
          if(Array.isArray(parsed)) { takeArrayCandidates(ctx, info, parsed); continue; }
        } else if(info.ext==='csv' || info.ext==='tsv'){ const parsed = await parseDelimitedFile(info.file, info.ext==='tsv'? '\t':undefined); takeArrayCandidates(ctx, info, parsed.rows); continue; }
        else if(info.ext==='xlsx' || info.ext==='xls'){ const sheets = await parseExcelFile(info.file); if(!sheets.length){ ctx.diag.push('[WARN] empty workbook'); continue; } for(const sheet of sheets){ ctx.diag.push(`  [INFO] sheet ${sheet.name}`); takeArrayCandidates(ctx, {path:`${info.path}:${sheet.name}`}, sheet.rows); } continue; }
        else if(info.ext==='kml' || info.ext==='kmz'){ ctx.pendingGeom.push({ kind: info.ext, info }); ctx.diag.push('[GEOM] KML/KMZ queued for geo ingest'); continue; }
        else if(['shp','dbf','shx','prj','cpg'].includes(info.ext)){ ctx.pendingGeom.push({ kind:'shapefile', info }); continue; }
        else if(info.ext==='txt'){ const txt = await info.file.text(); const parsed = tryParse(txt); if(parsed && typeof parsed==='object'){ if(handleJsonStructure(ctx, info, parsed)) continue; if(Array.isArray(parsed)) { takeArrayCandidates(ctx, info, parsed); continue; } }
        }
      }catch(err){
        ctx.diag.push(`  [WARN] ingest error: ${err.message}`);
        ctx.errors.push(`${info.path}: ${err.message}`);
      }
    }
    await ingestGeometry(ctx);
    let summaryParts=[];
    if(ctx.geomSummary?.parcel){ summaryParts.push(parcel: ~ sqm ()); }\r\n    if(ctx.geomSummary?.overlays){ summaryParts.push(overlays:  (~ sqm)); }\r\n  }
